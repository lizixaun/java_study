package chapter_4;

/**
 * @author 李子煊
 * @version 1.0
 */
public class BitOperator02 {
    public static void main(String[] args) {
        //得到结论（二进制）：无论是算数左还是右边，就是直接将数字左还是右移动几位然后，溢出部分不要，然后右移用算数符补充(最高位数字表示符号，考虑到有可能为负)，左移使用0补充，
        //得到结果（十进制）：向左移n位：就是：该数*2^n，右就是/2^n
        //int 所以本来的原码长这样 00000000 00000000 00000000 00000001然后低位溢出的意思是最右边的是低位，左边的是高位，低位溢出是指从最右边开始递出来，算数右移几位就溢出几位（放到外面）也就是这样
        //第一次溢出：00000000 00000000 00000000 0000000? 1(抵出来第一个低位---最后一个数)
        //溢出的样子：00000000 00000000 00000000 000000?? 01(然后使用符号位也就是第一个数字0来补充从高位再到低位)
        //补充一次：00000000 00000000 00000000 0000000? 01
        //二次：00000000 00000000 00000000 00000000 01因为低位溢出了所以，不要结果为
        //00000000 00000000 00000000 00000000
        int a=1>>2;
        //byte c=1<<7;//会报错所以，显示应该将需要类型为int,其实short也可以
        byte b=1<<2;//算数左移，换一个字节来推导（也就是8bit来推导）
        //原码：00000001规则是：符号位不变，低位补0.意思是除了符号位不变剩下的数字整体向左边移动几位，高位溢出也不要，然后使用0补全
        byte c=5<<4;
        System.out.println(c);
        System.out.println(5*2*2*2*2);//得到结果也就是移动几位就是在这数字的基础上乘以2的n次方
        byte a1=127>>1;
        System.out.println(a1);




    }
}
