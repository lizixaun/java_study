package chapter_4;

/**
 * @author 李子煊
 * @version 1.0
 */
public class BitOperator4_28 {
    public static void main(String[] args) {
        //1.先得到计算机的补码
        //2.2的补码 ==>2的原码（原码的意思也就是在计算机里面表达的样子）：000000000 00000000 00000000 00000010因为2是int，有4个字节，每个字节有八个比特
                    //2的补码00000000 00000000 00000000 00000010也是上面那个，因为整数的反码，补码一样
        //2.3的补码==>3的原码：000000000 00000000 00000000 00000011
                    //3的补码：000000000 00000000 00000000 00000011
        //3.按位与（按位&）
        //000000000 00000000 00000000 00000010
        //000000000 00000000 00000000 00000011
        //000000000 00000000 00000000 00000010按位与的结果（运算后的补码）看结果要看原码，因为是正数（所以三码合一）
        //结果转为十进制，得到2
        System.out.println(2&3);

        //推导
        //1.先得到-2的原码 100000000 00000000 00000000 00000010//二进制的第一个数字是符号位
        //2.运算是以补码方式运行：得到-2的补码需要先得到-2的反码（符号位不变，其他位置取反）：11111111 11111111  11111111  11111101
        //-2的反码            11111111 11111111  11111111  11111101
        //3.补码（加1）       11111111 11111111  11111111  11111110
        //4.操作：对-2的补码进行取反操作：0变1，1变0
        // （运算后的补码）    00000000 00000000 00000000 00000001
        //需要看运算后的补码对应的原码。因为为0所以又是一个正数（0开头的）
        //所以运算后的原码就是 00000000 00000000 00000000 00000001
        System.out.println(~-2);//所以结果为1

        //推导
        //1.得到2的补码，2是正数所以原码等于补码 00000000 00000000 00000000 00000010
        //操作：按位取反~2                      11111111 11111111 11111111 11111101（运算后的补码）运算后的补码需要推算为原码（因为无论是什么码他的第一个数字都不会变一直是代表正负数）
        //因为是1开头的所以是负数（上面的是正数三码合一，所以不要推）
        //3.运算完的原码：补码-1（得到反码）     11111111 11111111 11111111 11111100
        //4.运算后的原码：因为反码是原码符号位不变，取反所以原码等于
                                            // 10000000 00000000 00000000 00000011==》-3
        System.out.println(~2);//-3
    }
}
